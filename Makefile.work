##########################################################################
##########################################################################
### You shouldn't need to change anything below here from project
### to project.  If you do, let me know so I can fold it back into the
### template! -Bret
##########################################################################
##########################################################################


##########################################################################
### Determine the current build
##########################################################################

# some useful variables
colon:= :
empty:=
space:= $(empty) $(empty)

ifdef BUILDNAME
# if BUILDNAME has been defined (as an environment var), make sure it's valid
BUILDNAME	:= $(filter $(BUILDNAMES), $(BUILDNAME))
endif

# look for any build names specified on the command line
CMDBUILDNAME	:= $(filter $(BUILDNAMES), $(MAKECMDGOALS))

# a build specified on the cmd line has priority
ifneq ($(words $(CMDBUILDNAME)),0)
BUILDNAME	:= $(CMDBUILDNAME)
endif

# make sure that exactly one or zero build names are specified
ifneq ($(words $(BUILDNAME)),0)
ifneq ($(words $(BUILDNAME)),1)
ERROR		+= Error: Please specify only one build name.\\n
endif
endif

# strip out any remaining spaces
BUILDNAME	:= $(subst $(space),$(empty),$(BUILDNAME))

# If no build was specified, use the default build
ifeq ($(words $(BUILDNAME)),0)
BUILDNAME	:= $(DEFAULTBUILD)
endif

# If only a build name was specified on the command line, we need the rule for
# the build to depend on the target 'all.'  Conversely, if the user specified
# a target on the command line make shouldn't do anything when it processes
# the build name as a target.
# SO, check to see if the user specified a goal on the command line
CMDLINE 	:= $(filter-out $(BUILDNAMES), $(MAKECMDGOALS))
ifneq ($(words $(CMDLINE)),0)
USER_SPEC_GOAL	:= 1
endif


##########################################################################
### What platform are we building for?
##########################################################################

PLATFORM	+= $($(BUILDNAME)_PLATFORM)

ifeq ($(words $(PLATFORM)),0)
PLATFORM	= ps2
endif

##########################################################################
### Tools and Tool Locations
##########################################################################

# should we print the commands used to build targets?
ifeq ($(strip $(PRINT_CMDS)),0)
SILENCE		= @
endif

# What tools to use.

ifeq ($(PLATFORM),ps2)
PREFIX		= ee-
BINLOADER	= $(DSEDB) -r run
endif

ifeq ($(PLATFORM),linux)
LINUX_DVP_FIX	= ee-
endif

ifeq ($(PLATFORM),linux_cross)
PREFIX		= $(PS2DEVDIR)/bin/ee-
BINLOADER	=
endif

AR		= $(SILENCE)$(PREFIX)ar
AS		= $(SILENCE)$(PREFIX)gcc
APP		= $(PREFIX)gasp
CC		= $(SILENCE)$(PREFIX)gcc
LD		= $(SILENCE)$(PREFIX)gcc
DVPASM		= dvp-as
OBJDUMP		= $(SILENCE)$(PREFIX)objdump
RM		= /bin/rm -fr
SHELL		= /bin/sh
CPP		= gcc -E
CDEP		= $(PREFIX)gcc -M
DSEDB		= $(SCEDIR)/bin/dsedb

# How to run the executable...
RUN		= $(BINLOADER) $(TARGETOBJ) $(RUNARGS) $($(BUILDNAME)_RUNARGS)

# ...or have the debug session launched in a new window... Useful if you're
# running from within an editor or are outputting color codes, etc. that
# require a terminal to interpret them.
XRUN		= $(TERM) -fg white -bg black -T "PSX2: Executing $(TARGET)" -sl 5000 -sb -g 140x40 -e bash -c "($(RUN); echo 'Press Enter to continue'; read)"

# the program that generates dependency rules for vsm files; needs to be in your path!
VSMDEP		= $(PS2STUFF)/tools/vsmdeps/vsmdeps.pl

# a program to pre-process vsm files; needs to be in your path!
VPP		= $(PS2STUFF)/tools/vu_reg_manager/vu_reg_manager.pl

# Stewart Sargaison's vu microcode optimizer
VCL		= vcl

# how to print out messages (Compiling somefile.cpp...)
PRINTMSG	= @echo -e -n

##########################################################################
### Build directory names and search paths
##########################################################################

# Where to generate/find dependency files.
DEPDIR		= $(DEPDIRBASE)_$(BUILDNAME)

# Where to generate/find object files.
OBJDIR		= $(OBJDIRBASE)_$(BUILDNAME)

# add build-specific INCDIRS
INCDIRS		+= $($(BUILDNAME)_INCDIRS)

# add build-specific LIBDIRS
LIBDIRS		+= $($(BUILDNAME)_LIBDIRS)

# add build-specific LIBDIRS
SRCDIRS		+= $($(BUILDNAME)_SRCDIRS)

# Find headers automatically.
vpath %.h	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(INCDIRS))

# Find source automatically.
vpath %.c	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))
vpath %.C	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))
vpath %.cc	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))
vpath %.cpp	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))

# Find libraries automatically.
vpath %.a	.:$(subst $(space),$(colon),$(LIBDIRS))

# Find assembly code automatically.
vpath %.s	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))
vpath %.vsm	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))
vpath %.vcl	.:$(subst $(space),$(colon),$(SRCDIRS)):$(subst $(space),$(colon),$(LIBDIRS))

# Find object files automatically
vpath %.o	:$(OBJDIR):$(subst $(space),$(colon),$(SRCDIRS))
vpath %.vo	:$(OBJDIR):$(subst $(space),$(colon),$(SRCDIRS))
vpath %.do	:$(OBJDIR):$(subst $(space),$(colon),$(SRCDIRS))

##########################################################################
### Build list of objects to make
##########################################################################

# Add build-specific sources
SRCS		+= $($(BUILDNAME)_SRCS)

# Filter out C and C++ files so we can build them with different flags.
CSRCS		+= $(filter %.c, $(SRCS))
CXXSRCS		+= $(filter %.C, $(SRCS))
CCSRCS		+= $(filter %.cc, $(SRCS))
CPPSRCS		+= $(filter %.cpp, $(SRCS))
VSMSRCS		+= $(filter %.vsm, $(SRCS))
DSMSRCS		+= $(filter %.dsm, $(SRCS))
VCLSRCS		+= $(filter %.vcl, $(SRCS))

# Generate the full list of object files.
AUTOOBJS	+= $(CPPSRCS:.cpp=.o) $(CCSRCS:.cc=.o) $(CXXSRCS:.C=.o)
AUTOOBJS	+= $(CSRCS:.c=.o)
AUTOOBJS	+= $(VSMSRCS:.vsm=.vo)
AUTOOBJS	+= $(DSMSRCS:.dsm=.do)
AUTOOBJS	+= $(VCLSRCS:.vcl=.vo)

ALLOBJS		= $(AUTOOBJS) $(OBJS)

# The actual target binary name
TARGETOBJ	= $(addprefix $(OBJDIR)/, $(TARGET))

##########################################################################
### Assembler, compiler, and linker flags
##########################################################################

# which version of ee-gcc are we using?
GCC		:= $(subst $(SILENCE),,$(CC))
GCC_VERSION	:= $(shell $(GCC) --version)
GCC_VER_SPLIT	:= $(subst ., ,$(GCC_VERSION))
GCC_MAJOR	:= $(word 1, $(GCC_VER_SPLIT))
GCC_MINOR	:= $(word 2, $(GCC_VER_SPLIT))

# Optimization flags.
OPTFLAGS	+= $($(BUILDNAME)_OPTFLAGS) $($(*)_OPTFLAGS) $($(*)_$(BUILDNAME)_OPTFLAGS)

# Debugging flags to pass to the compiler
DEBUGFLAGS	+= $($(BUILDNAME)_DEBUGFLAGS) $($(*)_DEBUGFLAGS) $($(*)_$(BUILDNAME)_DEBUGFLAGS)

# Make these lists into useful stuff.
ASMINCFLAGS	= $(addprefix -I, $(ASMINCDIRS) $($(BUILDNAME)_ASMINCDIRS) $($(*)_ASMINCDIRS) $($(*)_$(BUILDNAME)_ASMINCDIRS))
DEFFLAGS	= $(addprefix -D, $(DEFINES) $($(BUILDNAME)_DEFINES) $($(*)_DEFINES) $($(*)_$(BUILDNAME)_DEFINES))
# these two had their build-specific dirs added above the vpath directives
INCFLAGS	= $(addprefix -I, $(INCDIRS) $($(*)_INCDIRS) $($(*)_$(BUILDNAME)_INCDIRS))
LIBFLAGS	= $(addprefix -L, $(LIBDIRS) $($(*)_LIBDIRS) $($(*)_$(BUILDNAME)_LIBDIRS))

# Flags for compiling C files.
CFLAGS		= $(DEBUGFLAGS) $(OPTFLAGS) $(INCFLAGS) $(DEFFLAGS)

# Flags for compiling C++ files.
CXXFLAGS	= $(DEBUGFLAGS) $(OPTFLAGS) $(INCFLAGS) $(DEFFLAGS)

# Flags for the assemblers.
ASFLAGS		= -c -xassembler-with-cpp -Wa,-al $(INCFLAGS)
DVPASMFLAGS	=

# Flags for the linker.

ifeq ($(PLATFORM),ps2)
  ifeq ($(GCC_MAJOR),3)
    NOCRT0		= -mno-crt0
  else
    ifeq ($(GCC_MINOR),96-ee-001003)
      NOCRT0		= -mno-crt0
    else
      NOCRT0		= -nostartfiles
    endif
  endif
endif

LDFLAGS		= $(LINKFLAGS) $($(BUILDNAME)_LINKFLAGS) $(NOCRT0) $(DEBUGFLAGS) $(LIBFLAGS) -lm -lstdc++

ifneq (,$(findstring linux,$(PLATFORM)))
# don't warn about linking vu microcode into the executable
LDFLAGS		+= -Wl,--no-warn-mismatch
endif

# which linker command file do we use?

ifndef APP_CMD
  ifdef $(BUILDNAME)_APP_CMD
  APP_CMD		:= $(BUILDNAME)_APP_CMD
  else
  APP_CMD		:= $(SCEDIR)/ee/lib/app.cmd
  endif
endif

##########################################################################
### Libraries
##########################################################################

# add build-specific libraries to LIBS

LIBS		+= $($(BUILDNAME)_LIBS)

# The LIBS variable can contain long or short library names, for example
# 'packet' or 'libpacket.a'.  We'd like to produce a command line that
# uses the form '-lpacket' for libraries given in short form, so let's
# make a couple new variables to help with this

# first, separate the short and long names

SHORT_LIBS	:= $(filter-out lib%.a, $(LIBS))
LONG_LIBS	:= $(filter lib%.a, $(LIBS))

# we want make to find all the libraries using vpath for the dependencies,
# and for that it needs the full filename (eg, libpacket.a),
# so let's create yet another variable to hold the expanded filenames

SHORT_LIBS_EXP	:= $(patsubst %, lib%.a, $(SHORT_LIBS))

##########################################################################
### Messages
##########################################################################

# should we print status messages?
ifeq ($(strip $(PRINT_MSGS)),1)
COMP_MSG	= Compiling $<...\\n
ASM_MSG		= Assembling $<...\\n
VCL_MSG		= Optimizing $<...\\n
LINK_MSG	= Linking $@...\\n
AR_MSG		= Creating archive $@...\\n
RUN_MSG		= Executing $(TARGETOBJ)...\\n
XRUN_MSG	= $(RUN_MSG)
endif

##########################################################################
### Rules
##########################################################################

# This line lets us properly have files called "clean" or "tags"  in the
# directory if we really want to.
.PHONY: clean clean_all tags preBuild.phony rmPrebuilddone.phony checkError.phony $(BUILDNAMES)
.SUFFIXES:

# see note above in "Determine the current build"
ifeq ($(USER_SPEC_GOAL),1)
$(BUILDNAME): ;
else
$(BUILDNAME): all ;
endif

all: $(TARGETOBJ)

$(TARGETOBJ): $(ALLOBJS) $(LONG_LIBS) $(SHORT_LIBS_EXP)


### rule to build linux executables ###
ifneq (,$(findstring linux,$(PLATFORM)))

$(basename $(TARGETOBJ)).elf:
	$(PRINTMSG) $(LINK_MSG)
	$(LD) -o $@ 					\
	$(addprefix $(OBJDIR)/,$(AUTOOBJS))		\
	$(OBJS)						\
	$(filter $(addprefix %, $(LONG_LIBS)), $^)	\
	$(addprefix -l, $(SHORT_LIBS))			\
	$(LDFLAGS)
	$(PRINTMSG) \\n

### Rule to build elfs (ps2 executables) ###
else

# A lot of this is straightforward -- invoke the linker to produce
# the elf file using app.cmd (should probably be user-definable, per-build..).
# Link against crt0.o, user-specified objects in OBJS, and all of the
# objects we're responsible for building, found in OBJDIR, and oh yeah, use
# the link flags.  The only tricky thing is that we want make to find
# libraries given as "lib<name>.a" for us, so we take them from the
# list of dependencies, which contains a bunch of other stuff that we don't
# want.  Libraries give in short form (see above) we can just do -l<name>
# and let the linker deal with it.

$(basename $(TARGETOBJ)).elf: crt0.o $(APP_CMD)
	$(PRINTMSG) $(LINK_MSG)
	$(LD) -o $@ -T $(APP_CMD) crt0.o	\
	$(addprefix $(OBJDIR)/,$(AUTOOBJS))		\
	$(OBJS)						\
	$(filter $(addprefix %, $(LONG_LIBS)), $^)	\
	$(addprefix -l, $(SHORT_LIBS))			\
	$(LDFLAGS)
	$(PRINTMSG) \\n

endif # build linux or ps2 elfs

### Rule to build static libraries ###

$(basename $(TARGETOBJ)).a:
	$(PRINTMSG) $(AR_MSG)
	$(AR) -r $@ $(addprefix $(OBJDIR)/,$(AUTOOBJS)) $(OBJS)
	$(PRINTMSG) \\n

### Rules to build objects ###

$(OBJDIR):
	-@mkdir $(OBJDIR)

%.o : %.c
	$(PRINTMSG) $(COMP_MSG)
	$(CC) $(CFLAGS) -o $(OBJDIR)/$@ -c $< > $(OBJDIR)/$*.lst

%.o : %.cpp
	$(PRINTMSG) $(COMP_MSG)
	$(CC) $(CXXFLAGS) -o $(OBJDIR)/$@ -c $< > $(OBJDIR)/$*.lst

%.o : %.cc
	$(PRINTMSG) $(COMP_MSG)
	$(CC) $(CXXFLAGS) -o $(OBJDIR)/$@ -c $< > $(OBJDIR)/$*.lst

%.o : %.C
	$(PRINTMSG) $(COMP_MSG)
	$(CC) $(CXXFLAGS) -o $(OBJDIR)/$@ -c $< > $(OBJDIR)/$*.lst

%.o : %.s
	$(PRINTMSG) $(ASM_MSG)
	$(AS) $(ASFLAGS) -o $@ $< > $(OBJDIR)/$*.lst

### Rule to optimize vcl files ###

# example render.vcl:
# - sed strips out #includes and #defines and replaces '.include "filename"' with
#   '.include "../<dir of first dep>/filename"' (when filename doesn't begin with '/'),
#   then outputs objdir/render.vcl
# - gasp processes and pipes to sed
# - sed replaces [number] with _number, and [xyzw] with xyzw and outputs objdir/render2.vcl
# - vcl optimizes and outputs objdir/render3.vsm
# - run the c preprocessor over objdir/render3.vcl and write render_vcl.vsm (the 'cat'
#   is there because the preprocessor, 'gcc -E,' thinks that .vsm is a linker file)
%_vcl.vsm: %.vcl
	$(PRINTMSG) $(VCL_MSG)
	$(SILENCE)sed 's/#include[ 	]\+.\+// ; s/#define[ 	]\+.\+// ; s|\(\.include[ 	]\+\)"\([^/].\+\)"|\1"$(<D)/\2"|' \
	$< > $(OBJDIR)/$(<F)
	$(SILENCE)$(APP) -c ';' $(ASMINCFLAGS) $(OBJDIR)/$(<F) \
	| sed 's/\[\([0-9]\)\]/_\1/g ; s/\[\([w-zW-Z]\)\]/\1/g' - > $(OBJDIR)/$(*F)2.vcl
	$(SILENCE)$(VCL) $(VCLARGS) $($(BUILDNAME)_VCLARGS) -o$(OBJDIR)/$(*F)3.vsm $(OBJDIR)/$(*F)2.vcl
	$(SILENCE)cat $(OBJDIR)/$(*F)3.vsm | $(CPP) -P $(INCFLAGS) $(DEFFLAGS) $(addprefix -imacros , $($(*F)_vcl_INCLUDES)) - > $(<D)/$*_vcl.vsm

### rules to assemble vu microcode ###

ifeq ($(PLATFORM),ps2)
SED_VO_VSM	= 's/\#include[ \t]\+.\+//g'
else
SED_VO_VSM	= 's/\#include[ \t]\+.\+//g ; s/\.align [0-9]\+//g'
endif

# the variable <filenamestem>_INCLUDES is generated by vsmdeps.pl.. Just using the headers listed on
# the dependency list like we were before wasn't strictly correct..
%.vo: %.vsm
	$(PRINTMSG) $(ASM_MSG)
	$(SILENCE)$(VPP) $< \
	| sed $(SED_VO_VSM) - > $(OBJDIR)/$(*F)_preprocessed.vsm
	$(SILENCE)$(DVPASM) $(DVPASMFLAGS) -o $(OBJDIR)/$@ $(OBJDIR)/$(*F)_preprocessed.vsm

#	 | sed 's/#include[ \t]\+.\+//g' - \
#	 | $(CPP) -P $(INCFLAGS) $(DEFFLAGS) $(addprefix -imacros , $($(*F)_INCLUDES)) - > $(OBJDIR)/$(*F)_preprocessed.vsm

# we don't need to do anything other than run cpp on files generated by vcl
%.vo: %_vcl.vsm
	$(PRINTMSG) $(ASM_MSG)
	$(SILENCE)$(CPP) -P $(INCFLAGS) $(DEFFLAGS) $(addprefix -imacros , $($(*F)_INCLUDES)) $< \
	| $(DVPASM) $(DVPASMFLAGS) -o $(OBJDIR)/$@ -

%.do: %.dsm
	$(PRINTMSG) $(ASM_MSG)
	$(SILENCE)$(VPP) $< \
	| sed 's/#include[ \t]\+.\+//g' - \
	| $(CPP) -P $(INCFLAGS) $(DEFFLAGS) $(addprefix -imacros , $($(*F)_INCLUDES)) - > $(OBJDIR)/$(*F)_preprocessed.dsm
	$(SILENCE)$(DVPASM) $(DVPASMFLAGS) -o $(OBJDIR)/$@ $(OBJDIR)/$(*F)_preprocessed.dsm

### the "fake" targets ###

run: all
	$(PRINTMSG) $(RUN_MSG)
	$(SILENCE)$(RUN)

xrun: all
	$(PRINTMSG) $(XRUN_MSG)
	$(SILENCE)$(XRUN)

# Optional: generate source-browsing tags for Emacs
tags: TAGS
TAGS: $(SRCS)
	etags -C -S $(addsuffix /*.h,$(INCDIRS)) $^

# Get rid of intermediate files.
clean:
	-$(RM) crt0.o $(OBJDIR) $(DEPDIR) *.map *.lst core *.dis TAGS prebuilddone

clean_all:
	-$(RM) crt0.o $(OBJDIRBASE)_* $(DEPDIRBASE)_* *.map *.lst core *.dis TAGS prebuilddone

# Get rid of intermediate files (clean) plus files which you probably don't
# want in a "distributable" tree.
distclean: clean
	-$(RM) *~

### error checking ###

# Check for errors and make sure the OBJDIR directory exists.
Makefile: checkError.phony $(OBJDIR)

###############################################################################
# Rules for automatically generating and using dependencies.
###############################################################################

$(DEPDIR):
	-@mkdir $(DEPDIR)

$(DEPDIR)/%.d: %.c
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(CDEP) $(CFLAGS) $< \
		| sed '\''s/\($*\)\.o[ :]*/\1.o $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

$(DEPDIR)/%.d: %.cpp
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(CDEP) $(CXXFLAGS) $< \
		| sed '\''s/\($*\)\.o[ :]*/\1.o $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

$(DEPDIR)/%.d: %.cc
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(CDEP) $(CXXFLAGS) $< \
		| sed '\''s/\($*\)\.o[ :]*/\1.o $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

$(DEPDIR)/%.d: %.C
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(CDEP) $(CXXFLAGS) $< \
		| sed '\''s/\($*\)\.o[ :]*/\1.o $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

$(DEPDIR)/%.dv: %.vsm
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(VSMDEP) $< $(INCFLAGS) -endcppincludes $(ASMINCFLAGS) \
		| sed '\''s/\($*\)\.vo[ :]*/\1.vo $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

$(DEPDIR)/%.dd: %.dsm
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(VSMDEP) $< $(INCFLAGS) \
		| sed '\''s/\($*\)\.do[ :]*/\1.do $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

$(DEPDIR)/%.dl: %.vcl
	@echo "Making dependencies for $<..."
	$(SILENCE)$(SHELL) -ec '[ -d $(DEPDIR) ] || mkdir $(DEPDIR) ; \
		$(VSMDEP) $< $(INCFLAGS) \
		| sed '\''s/\($*\)\.vo[ :]*/\1.vo $(subst /,\/,$@) : /g'\'' > $@; \
		[ -s $@ ] || rm -f $@'

# List of all the dependency files we want to build
DEPS		= $(addprefix $(DEPDIR)/, $(CPPSRCS:.cpp=.d) $(CCSRCS:.cc=.d) $(CXXSRCS:.C=.d) $(CSRCS:.c=.d)
DEPS		+= $(VSMSRCS:.vsm=.dv) $(DSMSRCS:.dsm=.dd) $(VCLSRCS:.vcl=.dl))

# Cause those dependency makefiles to be built and silently include them.
ifeq ($(empty),$(findstring clean, $(MAKECMDGOALS)))
ifndef ERROR
-include $(DEPS)
endif
endif

###############################################################################
# Weird rules to force make to do things it wasn't meant to...
###############################################################################

# if an error has been found make a rule to echo it and quit, otherwise do nothing
ifdef ERROR
checkError.phony: ; $(PRINTMSG) $(ERROR) ; exit -1
else
checkError.phony: ;
endif

# this is here as a lousy hack to prevent recent versions of make from executing the rule to
# make preBuild.phony twice...  It creates the temporary file 'prebuilddone' which will be included
# the second time the Makefile is parsed to define a variable that prevents preBuild.phony from
# being included.  The file is removed by rmPrebuilddone.phony.
ifeq ($(empty),$(findstring clean, $(MAKECMDGOALS)))
-include prebuilddone
endif

# the rule to generate prebuilddone
prebuilddone : ; @echo "PREBUILD = done\\nMakefile: rmPrebuilddone.phony" > prebuilddone
# a rule to delete the file 'prebuilddone'
rmPrebuilddone.phony : ; @rm -f prebuilddone

# force the preBuild.phony rule to be executed before doing anything else:
ifneq ($(PREBUILD),done)
ifeq ($(empty),$(findstring clean, $(MAKECMDGOALS)))
-include preBuild.phony
endif
endif

# stuff to do before trying to build the target
# first check to see if we need to call make in another directory
ifneq ($(words $(MAKEPARENTS)),0)
CUR_DIR := $(shell pwd)
preBuild.phony:
	@$(foreach MAKEPARENT, $(MAKEPARENTS), cd $(MAKEPARENT) && $(MAKE) $(BUILDNAME) --no-print-directory; cd $(CUR_DIR); )
	$(PRINTMSG) \\n------------------------- Building $(TARGET)\; Current build = $(BUILDNAME)\\n\\n
else
preBuild.phony:
	$(PRINTMSG) \\n------------------------- Building $(TARGET)\; Current build = $(BUILDNAME)\\n\\n
endif


